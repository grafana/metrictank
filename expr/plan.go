package expr

import (
	"errors"
	"fmt"
	"io"

	"github.com/raintank/metrictank/api/models"
)

type Req struct {
	Query string
	From  uint32 // from for this particular pattern
	To    uint32 // to for this particular pattern
}

type Plan struct {
	Reqs          []Req  // data that needs to be fetched before functions can be executed
	funcs         []Func // top-level funcs to execute, the head of each tree for each target
	exprs         []*expr
	MaxDataPoints uint32
	From          uint32                  // global request scoped from
	To            uint32                  // global request scoped to
	data          map[Req][]models.Series // input data to work with. set via Run(), as well as
	// new data generated by processing funcs. useful for two reasons:
	// 1) reuse partial calculations e.g. queries like target=movingAvg(sum(foo), 10)&target=sum(foo) (TODO)
	// 2) central place to return data back to pool when we're done.
}

func (p Plan) Dump(w io.Writer) {
	fmt.Fprintf(w, "Plan:\n")
	fmt.Fprintf(w, "* Exprs:\n")
	for _, e := range p.exprs {
		fmt.Fprintln(w, e.Print(2))
	}
	fmt.Fprintf(w, "* Reqs:\n")
	for _, r := range p.Reqs {
		fmt.Fprintln(w, "   ", r)
	}
	fmt.Fprintf(w, "MaxDataPoints: %d\n", p.MaxDataPoints)
	fmt.Fprintf(w, "From: %d\n", p.From)
	fmt.Fprintf(w, "To: %d\n", p.To)
}

// Plan validates the expressions and comes up with the initial (potentially non-optimal) execution plan
// which is just a list of requests and the expressions.
// traverse tree and as we go down:
// * make sure function exists
// * tentative validation pre function call (number of args and type of args, to the extent it can be done in advance),
// * let function validate input arguments further (to the extend it can be done in advance)
// * allow functions to extend the notion of which data is required
// * future version: allow functions to mark safe to pre-aggregate using consolidateBy or not
func NewPlan(exprs []*expr, from, to, mdp uint32, stable bool, reqs []Req) (Plan, error) {
	var err error
	var funcs []Func
	for _, e := range exprs {
		var fn Func
		fn, reqs, err = newplan(e, from, to, stable, reqs)
		if err != nil {
			return Plan{}, err
		}
		funcs = append(funcs, fn)
	}
	return Plan{
		Reqs:          reqs,
		exprs:         exprs,
		funcs:         funcs,
		MaxDataPoints: mdp,
		From:          from,
		To:            to,
	}, nil
}

// consumeArg verifies that the argument at pos j matches the expected arg
// it's up to the caller to assure that j is valid before calling.
// if arg allows for multiple arguments, j is advanced to cover all accepted arguments.
// the returned j is always the index where the next argument should be.
// it stores all passed arguments, except when series are requested, those will need a separate pass
// after deducing the required from/to.
func consumeArg(args []*expr, j int, exp arg) (int, error) {
	got := args[j]
	switch v := exp.(type) {
	case argSeries, argSeriesList:
		if got.etype != etName && got.etype != etFunc {
			return 0, ErrBadArgumentStr{"func or name", string(got.etype)}
		}
	case argSeriesLists:
		if got.etype != etName && got.etype != etFunc {
			return 0, ErrBadArgumentStr{"func or name", string(got.etype)}
		}
		// special case! consume all subsequent args (if any) in args that will also yield a seriesList
		for len(args) > j+1 && (args[j+1].etype == etName || args[j+1].etype == etFunc) {
			j += 1
		}
	case argInt:
		if got.etype != etInt {
			return 0, ErrBadArgumentStr{"int", string(got.etype)}
		}
		for _, va := range v.validator {
			if err := va(got); err != nil {
				return 0, fmt.Errorf("%s: %s", v.key, err.Error())
			}
		}
		*v.val = got.int
	case argInts:
		if got.etype != etInt {
			return 0, ErrBadArgumentStr{"int", string(got.etype)}
		}
		*v.val = append(*v.val, got.int)
		// special case! consume all subsequent args (if any) in args that will also yield an integer
		for len(args) > j+1 && args[j+1].etype == etInt {
			j += 1
			for _, va := range v.validator {
				if err := va(args[j]); err != nil {
					return 0, fmt.Errorf("%s: %s", v.key, err.Error())
				}
			}
			*v.val = append(*v.val, args[j].int)
		}
	case argFloat:
		if got.etype != etFloat && got.etype != etInt {
			return 0, ErrBadArgumentStr{"float", string(got.etype)}
		}
		for _, va := range v.validator {
			if err := va(got); err != nil {
				return 0, fmt.Errorf("%s: %s", v.key, err.Error())
			}
		}
		*v.val = got.float
	case argString:
		if got.etype != etString {
			return 0, ErrBadArgumentStr{"string", string(got.etype)}
		}
		for _, va := range v.validator {
			if err := va(got); err != nil {
				return 0, fmt.Errorf("%s: %s", v.key, err.Error())
			}
		}
		*v.val = got.str
	case argBool:
		if got.etype != etBool {
			return 0, ErrBadArgumentStr{"string", string(got.etype)}
		}
		*v.val = got.bool
	}
	j += 1
	return j, nil
}

// consumeKwarg consumes the kwarg (by key k) and verifies it
// it's the callers responsability that k exists within namedArgs
// it also makes sure the kwarg has not been consumed already via the kwargs map
// (it would be an error to provide an argument twice via the same keyword,
// or once positionally and once via keyword)
func consumeKwarg(namedArgs map[string]*expr, k string, optArgs []arg, seenKwargs map[string]struct{}) error {
	var found bool
	var exp arg
	for _, exp = range optArgs {
		if exp.Key() == k {
			found = true
			break
		}
	}
	if !found {
		return ErrUnknownKwarg{k}
	}
	_, ok := seenKwargs[k]
	if ok {
		return ErrKwargSpecifiedTwice{k}
	}
	seenKwargs[k] = struct{}{}
	got := namedArgs[k]
	switch v := exp.(type) {
	case argInt:
		if got.etype != etInt {
			return ErrBadKwarg{k, exp, got.etype}
		}
		*v.val = got.int
	case argFloat:
		// integer is also a valid float, just happened to have no decimals
		if got.etype != etInt && got.etype != etFloat {
			return ErrBadKwarg{k, exp, got.etype}
		}
		*v.val = got.float
	case argString:
		if got.etype != etString {
			return ErrBadKwarg{k, exp, got.etype}
		}
		*v.val = got.str
	}
	return nil
}

func consumeSeriesArg(args []*expr, j int, exp arg, from, to uint32, stable bool, reqs []Req) (int, []Req, error) {
	got := args[j]
	var err error
	var fn Func
	switch v := exp.(type) {
	case argSeries:
		if got.etype != etName && got.etype != etFunc {
			return 0, nil, ErrBadArgumentStr{"func or name", string(got.etype)}
		}
		fn, reqs, err = newplan(got, from, to, stable, reqs)
		if err != nil {
			return 0, nil, err
		}
		*v.val = fn
	case argSeriesList:
		if got.etype != etName && got.etype != etFunc {
			return 0, nil, ErrBadArgumentStr{"func or name", string(got.etype)}
		}
		fn, reqs, err = newplan(got, from, to, stable, reqs)
		if err != nil {
			return 0, nil, err
		}
		*v.val = fn
	case argSeriesLists:
		if got.etype != etName && got.etype != etFunc {
			return 0, nil, ErrBadArgumentStr{"func or name", string(got.etype)}
		}
		fn, reqs, err = newplan(got, from, to, stable, reqs)
		if err != nil {
			return 0, nil, err
		}
		*v.val = append(*v.val, fn)
		// special case! consume all subsequent args (if any) in args that will also yield a seriesList
		for len(args) > j+1 && (args[j+1].etype == etName || args[j+1].etype == etFunc) {
			j += 1
			fn, reqs, err = newplan(args[j], from, to, stable, reqs)
			if err != nil {
				return 0, nil, err
			}
			*v.val = append(*v.val, fn)
		}
	default:
		panic("unsupported type for consumeSeriesArg")
	}
	j += 1
	return j, reqs, nil
}

// newplan adds requests as needed for the given expr, resolving function calls as needed
func newplan(e *expr, from, to uint32, stable bool, reqs []Req) (Func, []Req, error) {
	if e.etype != etFunc && e.etype != etName {
		return nil, nil, errors.New("request must be a function call or metric pattern")
	}
	if e.etype == etName {
		req := Req{
			e.str,
			from,
			to,
		}
		reqs = append(reqs, req)
		return NewGet(req), reqs, nil
	}

	// here e.type is guaranteed to be etFunc
	fdef, ok := funcs[e.str]
	if !ok {
		return nil, nil, ErrUnknownFunction(e.str)
	}
	if stable && !fdef.stable {
		return nil, nil, ErrUnknownFunction(e.str)
	}

	fn := fdef.constr()
	reqs, err := newplanFunc(e, fn, from, to, stable, reqs)
	return fn, reqs, err
}

// newplanFunc adds requests as needed for the given expr, and validates the function input
// provided you already know the expression is a function call to the given function
func newplanFunc(e *expr, fn Func, from, to uint32, stable bool, reqs []Req) ([]Req, error) {
	// first comes the interesting task of validating the arguments as specified by the function,
	// against the arguments that were parsed.

	argsExp, _ := fn.Signature()
	var err error

	// note:
	// * signature may have seriesLists in it, which means one or more args of type seriesList
	//   so it's legal to have more e.args than signature args in that case.
	// * we can't do extensive, accurate validation of the type here because what the output from a function we depend on
	//   might be dynamically typed. e.g. movingAvg returns 1..N series depending on how many it got as input

	// first validate the mandatory args
	j := 0      // pos in args of next given arg to process
	cutoff := 0 // marks the index of the first optional point (if any)
	var argExp arg
	for cutoff, argExp = range argsExp {
		if argExp.Optional() {
			break
		}
		if len(e.args) <= j {
			return nil, ErrMissingArg
		}
		j, err = consumeArg(e.args, j, argExp)
		if err != nil {
			return nil, err
		}
	}
	if !argExp.Optional() {
		cutoff += 1
	}

	// we stopped iterating the mandatory args.
	// any remaining args should be due to optional args otherwise there's too many
	// we also track here which keywords can also be used for the given optional args
	// so that those args should not be specified via their keys anymore.

	seenKwargs := make(map[string]struct{})
	for _, argOpt := range argsExp[cutoff:] {
		if len(e.args) <= j {
			break // no more args specified. we're done.
		}
		j, err = consumeArg(e.args, j, argOpt)
		if err != nil {
			return nil, err
		}
		seenKwargs[argOpt.Key()] = struct{}{}
	}
	if len(e.args) > j {
		return nil, ErrTooManyArg
	}

	// for any provided keyword args, verify that they are what the function stipulated
	// and that they have not already been specified via their position
	for k := range e.namedArgs {
		err = consumeKwarg(e.namedArgs, k, argsExp[cutoff:], seenKwargs)
		if err != nil {
			return nil, err
		}

	}

	// functions now know all non-series input args -> they know the timerange they need
	from, to = fn.NeedRange(from, to)
	// we know timerange -> set up input series
	j = 0
	for _, argExp = range argsExp[:cutoff] {
		switch argExp.(type) {
		case argSeries, argSeriesList, argSeriesLists:
			j, reqs, err = consumeSeriesArg(e.args, j, argExp, from, to, stable, reqs)
			if err != nil {
				return nil, err
			}
		default:
			return reqs, err
		}
	}
	return reqs, err
}

// Run invokes all processing as specified in the plan (expressions, from/to) with the input as input
func (p Plan) Run(input map[Req][]models.Series) ([]models.Series, error) {
	var out []models.Series
	p.data = input
	for _, fn := range p.funcs {
		series, err := fn.Exec(p.data)
		if err != nil {
			return nil, err
		}
		out = append(out, series...)
	}
	return out, nil
}

// Clean returns all buffers (all input data + generated series along the way)
// back to the pool.
func (p Plan) Clean() {
	for _, series := range p.data {
		for _, serie := range series {
			pointSlicePool.Put(serie.Datapoints[:0])
		}
	}
}
